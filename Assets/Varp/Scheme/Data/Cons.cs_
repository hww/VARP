/* 
 * Copyright (c) 2016 Valery Alex P.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using System.Collections;
using System.Collections.Generic;
using System.Text;
using UnityEngine;
using VAP.Scheme.Exception;
using VAP.Scheme.REPL;

namespace VAP.Scheme.Data
{

    public class Cons : SObject, IEnumerable<SObject>
    {
        private SObject car = null;
        private SObject cdr = null;

        public Cons()
        {
        }
        public Cons(SObject car)
        {
            this.car = car;
        }
        public Cons(SObject car, SObject cdr)
        {
            this.car = car;
            this.cdr = cdr;
        }
        public static SObject Car(SObject cons)
        {
            if (cons is Cons) return ((Cons)cons).car;
            if (cons == null) return cons;
            throw new SchemeException(string.Format("SObject {0} is not a cons", cons));
        }
        public static SObject Cdr(SObject cons)
        {
            if (cons is Cons) return ((Cons)cons).cdr;
            if (cons == null) return cons;
            throw new SchemeException(string.Format("SObject {0} is not a cons", cons));
        }
        public static SObject SetCar(SObject c, SObject v)
        {
            if (c is Cons) ((Cons)c).car = v;
            else throw new SchemeException(string.Format("SObject {0} is not a cons", c));
            return SVoid.Void;
        }
        public static SObject SetCdr(SObject c, SObject v)
        {
            if (c is Cons) ((Cons)c).cdr = v;
            else throw new SchemeException(string.Format("SObject {0} is not a cons", c));
            return SVoid.Void;
        }

        #region Working with CAR and CDR
        public static SObject Caar(SObject cons) { return Car(Car(cons)); }
        public static SObject SetCaar(SObject cons, SObject o) { return SetCar(Car(cons), o); }
        public static SObject Cadr(SObject cons) { return Car(Cdr(cons)); }
        public static SObject SetCadr(SObject cons, SObject o) { return SetCar(Cdr(cons), o); }
        public static SObject Cdar(SObject cons) { return Cdr(Car(cons)); }
        public static SObject SetCdar(SObject cons, SObject o) { return SetCdr(Car(cons), o); }
        public static SObject Cddr(SObject cons) { return Cdr(Cdr(cons)); }
        public static SObject SetCddr(SObject cons, SObject o) { return SetCdr(Cdr(cons), o); }
        public static SObject Caaar(SObject cons) { return Car(Car(Car(cons))); }
        public static SObject SetCaaar(SObject cons, SObject o) { return SetCar(Car(Car(cons)), o); }
        public static SObject Caadr(SObject cons) { return Car(Car(Cdr(cons))); }
        public static SObject SetCaadr(SObject cons, SObject o) { return SetCar(Car(Cdr(cons)), o); }
        public static SObject Cadar(SObject cons) { return Car(Cdr(Car(cons))); }
        public static SObject SetCadar(SObject cons, SObject o) { return SetCar(Cdr(Car(cons)), o); }
        public static SObject Caddr(SObject cons) { return Car(Cdr(Cdr(cons))); }
        public static SObject SetCaddr(SObject cons, SObject o) { return SetCar(Cdr(Cdr(cons)), o); }
        public static SObject Cdaar(SObject cons) { return Cdr(Car(Car(cons))); }
        public static SObject SetCdaar(SObject cons, SObject o) { return SetCdr(Car(Car(cons)), o); }
        public static SObject Cdadr(SObject cons) { return Cdr(Car(Cdr(cons))); }
        public static SObject SetCdadr(SObject cons, SObject o) { return SetCdr(Car(Cdr(cons)), o); }
        public static SObject Cddar(SObject cons) { return Cdr(Cdr(Car(cons))); }
        public static SObject SetCddar(SObject cons, SObject o) { return SetCdr(Cdr(Car(cons)), o); }
        public static SObject Cdddr(SObject cons) { return Cdr(Cdr(Cdr(cons))); }
        public static SObject SetCdddr(SObject cons, SObject o) { return SetCdr(Cdr(Cdr(cons)), o); }

        #endregion

        public static SObject Reverse(SObject obj)
        {

            Cons cons = SObjectCast.GetPair(obj);
            SObject reversed = null;
            while (cons != null)
            {
                reversed = new Cons(Cons.Car(cons), reversed);
                cons = SObjectCast.GetPair(Cons.Cdr(cons));
            }
            return reversed;
        }
        public static int Length(SObject obj)
        {
            Cons cons = SObjectCast.GetPair(obj);
            int length = 0;
            while (cons != null)
            {
                length++;
                cons = SObjectCast.GetPair(Cons.Cdr(cons));
            }
            return length;
        }

        public static SObject[] ToReverseObjectArray(SObject obj)
        {
            Cons cons = SObjectCast.GetPair(obj);
            int length = Cons.Length(cons);
            SObject[] objs = new SObject[length];
            for (int x = 0; x < length; x++)
            {
                objs[length - 1 - x] = Cons.Car(cons);
                cons = SObjectCast.GetPair(Cons.Cdr(cons));
            }
            return objs;
        }
        public static SObject[] ToObjectArray(SObject obj)
        {
            Cons cons = SObjectCast.GetPair(obj);
            int length = Length(cons);
            SObject[] objs = new SObject[length];
            for (int x = 0; x < length; x++)
            {
                objs[x] = Cons.Car(cons);
                cons = SObjectCast.GetPair(Cons.Cdr(cons));
            }
            return objs;
        }
        public static SObject ConsFromIEnumerable(IEnumerable<SObject> collection)
        {
            SObject c = null;
            foreach (var thing in collection)
            {
                c = new Cons(thing, c);
            }
            return Cons.Reverse(c);
        }
        public static SObject ConsFromArray(SObject[] array)
        {
            SObject c = null;
            for (int x = 0; x < array.Length; x++)
            {
                c = new Cons(array[x], c);
            }
            return Cons.Reverse(c);
        }
        public static SObject ConsFromArray(ArrayList array)
        {
            SObject c = null;
            for (int x = 0; x < array.Count; x++)
            {
                c = new Cons(array[x] as SObject, c);
            }
            return Cons.Reverse(c);
        }
        public static Cons GetLast(SObject obj)
        {
            Cons cons = SObjectCast.GetPair(obj);
            if (cons == null) return null;
            while (cons.cdr != null)
            {
                if (cons.cdr is Cons)
                    cons = cons.cdr as Cons;
                else
                    // return last element with dot (x y . z) returns (y . z)
                    return cons;    
            }
            return cons;
        }
        public static SObject AddFirst(SObject obja, SObject objb)
        {
            Cons cons = SObjectCast.GetPair(obja);
            Cons ret = new Cons(objb, cons);
            return ret;
        }
        public static SObject AddLast(SObject obja, SObject type)
        {
            Cons cons = SObjectCast.GetPair(obja);
            if (cons == null) return new Cons(type, null);
            Debug.Assert(cons is Cons);
            Cons last = GetLast(cons);
            SetCdr(last, new Cons(type, null));
            return cons;
        }
        public static SObject Append(SObject consa, SObject consb)
        {
            if (consa == null && consb == null)
                return null;
            else if (consa == null)
                return consb;
            else if (consb == null)
                return consa;
            Cons a = SObjectCast.GetList(consa);
            Cons.SetCdr(a, consb);
            return consa;
        }
        public static Cons AddLastCons(SObject cons, SObject type)
        {
            if (cons == null) return new Cons(type, null);
            Cons last = GetLast(cons);
            SetCdr(last, new Cons(type, null));
            return cons as Cons;
        }

        public Cons ListCdr()
        {
            Cons ret = (Cons)this.cdr;
            if (ret == null)
                return new Cons();

            return ret;
        }
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        public IEnumerator<SObject> GetEnumerator()
        {
            Cons c = this;
            while (c != null)
            {
                yield return c.car;
                c = (Cons)c.cdr;
            }
        }

        public static bool IsEmpty(Cons cons)
        {
            return (cons.car == null && cons.cdr == null);
        }




        public static Cons PairAtIndex(Cons cons, int index)
        {
            if (index < 0) throw new System.IndexOutOfRangeException("Attempt to access a negative index while using the indexer for a Pair");

            while (index > 0)
            {
                SObject nextPair = Cons.Cdr(cons);

                if (nextPair is Cons)
                {
                    cons = (Cons)Cons.Cdr(cons);
                }
                else
                {
                    if (index == 1) throw new System.IndexOutOfRangeException("Pair represents an improper list");
                }
                if (cons.IsNull) throw new System.IndexOutOfRangeException("Attempt to access beyond the end of a Pair list");
                index--;
            }

            return cons;
        }


        #region SObject Methods
        public override bool IsList { get { return cdr is Cons || cdr.IsNull; } }
        public override bool IsPair { get { return !(cdr is Cons || cdr.IsNull); } }
        public override bool IsLiteral { get { return false; } }
        public override SBool AsBool() { return SBool.True; }
        public override string AsString() { return string.Format("{0} {1}>", car.AsString(), cdr.AsString()); }
 


        #endregion
    }


}